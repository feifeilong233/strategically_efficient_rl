import numpy as np

from normal_form.solvers import build_solver


class ExploreExploit:

    def __init__(self, N, M, T, config):

        # Get exploration mode
        self._exploration_mode = config.get("exploration", "uniform")
        
        # Get solver
        solver = config.get("solver", "hedge")
        solver_config = config.get("solver_config", {})
        self._solver = build_solver(solver, solver_config)

        # Initialize model
        self._sample_counts = np.zeros((N,M,))
        self._row_totals = np.zeros((N,M,))

    def sample(self, G): # Generate samples from the game G - return 
        if "min_count" == self._exploration_mode:
            row_action, column_action = np.unravel_index(np.argmin(self._sample_counts), 
                self._sample_counts.shape)
        else:
            row_action = np.random.randint(0, self._sample_counts.shape[0])
            column_action = np.random.randint(0, self._sample_counts.shape[1])

        # Sample payoff
        row_payoff, column_payoff = G.sample(row_action, column_action)
        
        self._sample_counts[row_action, column_action] += 1
        self._row_totals += row_payoff

    def strategies(self): # Return the test strategies, may differ from the sampling strategies
        counts = np.maximum(self._sample_counts, np.ones(self._sample_counts.shape))
        row_game = self._row_totals / counts
        row_strategy, column_strategy, _ = self._solver(row_game, 1.0 - row_game)
        
        return row_strategy, column_strategy

    def __repr__(self):
        return f"explore_exploit_{self._solver}_{self._exploration_mode}"
